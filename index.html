<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Крестики-нолики</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }
        
        .game-board {
            flex: 1;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .game-mode {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .difficulty {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
            align-items: center;
        }
        
        .difficulty-title {
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .mode-btn, .difficulty-btn {
            padding: 10px 20px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .mode-btn.active, .difficulty-btn.active {
            background: #4da6ff;
            border-color: #4da6ff;
        }
        
        .difficulty-btn.easy.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .difficulty-btn.medium.active {
            background: #FF9800;
            border-color: #FF9800;
        }
        
        .difficulty-btn.hard.active {
            background: #F44336;
            border-color: #F44336;
        }
        
        .status {
            margin: 20px 0;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            min-height: 40px;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin: 20px 0;
        }
        
        .cell {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .cell:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-3px);
        }
        
        .cell.x {
            color: #ff4d4d;
        }
        
        .cell.o {
            color: #4da6ff;
        }
        
        .reset-btn {
            padding: 12px 30px;
            font-size: 1.1rem;
            background: #4da6ff;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .reset-btn:hover {
            background: #3385d6;
            transform: translateY(-3px);
        }
        
        .ad-container {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .ad-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .ad-content {
            width: 100%;
            height: 250px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }
        
        .ad-text {
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .ad-placeholder {
            font-size: 3rem;
            margin-bottom: 20px;
            opacity: 0.7;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        @media (max-width: 700px) {
            .game-container {
                flex-direction: column;
            }
            
            .game-board, .ad-container {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Крестики-нолики</h1>
            <p>Классическая игра для двух игроков или против бота</p>
        </header>
        
        <div class="game-container">
            <div class="game-board">
                <div class="game-mode">
                    <button class="mode-btn active" id="modeTwoPlayers">Два игрока</button>
                    <button class="mode-btn" id="modeVsBot">Против бота</button>
                </div>
                
                <div class="difficulty" id="difficultyContainer">
                    <div class="difficulty-title">Уровень сложности:</div>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn easy active" id="difficultyEasy">Деградант</button>
                        <button class="difficulty-btn medium" id="difficultyMedium">Нормис</button>
                        <button class="difficulty-btn hard" id="difficultyHard">Ну сука точно умнее твоей мамаши</button>
                    </div>
                </div>
                
                <div class="status" id="status">Ход игрока: X</div>
                <div class="board" id="board">
                    <div class="cell" data-index="0"></div>
                    <div class="cell" data-index="1"></div>
                    <div class="cell" data-index="2"></div>
                    <div class="cell" data-index="3"></div>
                    <div class="cell" data-index="4"></div>
                    <div class="cell" data-index="5"></div>
                    <div class="cell" data-index="6"></div>
                    <div class="cell" data-index="7"></div>
                    <div class="cell" data-index="8"></div>
                </div>
                <button class="reset-btn" id="reset">Новая игра</button>
            </div>
            
            <div class="ad-container">
                <h2 class="ad-title">Рекламный блок</h2>
                <div class="ad-content">
                    <div class="ad-placeholder">Реклама</div>
                    <p class="ad-text">Здесь может быть размещена ваша реклама</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>© 2025 Крестики-нолики. Все права защищены.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const statusDisplay = document.getElementById('status');
            const cells = document.querySelectorAll('.cell');
            const resetButton = document.getElementById('reset');
            const modeTwoPlayersBtn = document.getElementById('modeTwoPlayers');
            const modeVsBotBtn = document.getElementById('modeVsBot');
            const difficultyContainer = document.getElementById('difficultyContainer');
            const difficultyEasyBtn = document.getElementById('difficultyEasy');
            const difficultyMediumBtn = document.getElementById('difficultyMedium');
            const difficultyHardBtn = document.getElementById('difficultyHard');
            
            let gameActive = true;
            let currentPlayer = "X";
            let gameState = ["", "", "", "", "", "", "", "", ""];
            let vsBotMode = false;
            let botDifficulty = "easy"; // По умолчанию легкий уровень
            
            const winningConditions = [
                [0, 1, 2],
                [3, 4, 5],
                [6, 7, 8],
                [0, 3, 6],
                [1, 4, 7],
                [2, 5, 8],
                [0, 4, 8],
                [2, 4, 6]
            ];
            
            const winningMessage = () => `Победил игрок ${currentPlayer}!`;
            const drawMessage = () => `Ничья!`;
            const currentPlayerTurn = () => `Ход игрока: ${currentPlayer}`;
            
            statusDisplay.innerHTML = currentPlayerTurn();
            
            // Сначала скрываем выбор уровня сложности
            difficultyContainer.style.display = 'none';
            
            function handleCellClick(clickedCellEvent) {
                const clickedCell = clickedCellEvent.target;
                const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index'));
                
                if (gameState[clickedCellIndex] !== "" || !gameActive) {
                    return;
                }
                
                handleCellPlayed(clickedCell, clickedCellIndex);
                handleResultValidation();
                
                // Если режим против бота и игра продолжается, ходит бот
                if (vsBotMode && gameActive && currentPlayer === "O") {
                    setTimeout(botMove, 500);
                }
            }
            
            function handleCellPlayed(clickedCell, clickedCellIndex) {
                gameState[clickedCellIndex] = currentPlayer;
                clickedCell.innerHTML = currentPlayer;
                clickedCell.classList.add(currentPlayer.toLowerCase());
            }
            
            function handleResultValidation() {
                let roundWon = false;
                for (let i = 0; i < winningConditions.length; i++) {
                    const winCondition = winningConditions[i];
                    let a = gameState[winCondition[0]];
                    let b = gameState[winCondition[1]];
                    let c = gameState[winCondition[2]];
                    
                    if (a === '' || b === '' || c === '') {
                        continue;
                    }
                    
                    if (a === b && b === c) {
                        roundWon = true;
                        break;
                    }
                }
                
                if (roundWon) {
                    statusDisplay.innerHTML = winningMessage();
                    gameActive = false;
                    return;
                }
                
                let roundDraw = !gameState.includes("");
                if (roundDraw) {
                    statusDisplay.innerHTML = drawMessage();
                    gameActive = false;
                    return;
                }
                
                handlePlayerChange();
            }
            
            function handlePlayerChange() {
                currentPlayer = currentPlayer === "X" ? "O" : "X";
                statusDisplay.innerHTML = currentPlayerTurn();
            }
            
            function handleRestartGame() {
                gameActive = true;
                currentPlayer = "X";
                gameState = ["", "", "", "", "", "", "", "", ""];
                statusDisplay.innerHTML = currentPlayerTurn();
                cells.forEach(cell => {
                    cell.innerHTML = "";
                    cell.classList.remove("x", "o");
                });
                
                // Если режим против бота и бот ходит первым
                if (vsBotMode && currentPlayer === "O") {
                    setTimeout(botMove, 500);
                }
            }
            
            function botMove() {
                if (!gameActive || currentPlayer !== "O") return;
                
                let availableCells = [];
                gameState.forEach((cell, index) => {
                    if (cell === "") availableCells.push(index);
                });
                
                let moveIndex;
                
                // Выбор хода в зависимости от уровня сложности
                switch(botDifficulty) {
                    case "easy":
                        moveIndex = getEasyMove(availableCells);
                        break;
                    case "medium":
                        moveIndex = getMediumMove(availableCells);
                        break;
                    case "hard":
                        moveIndex = getHardMove(availableCells);
                        break;
                    default:
                        moveIndex = getEasyMove(availableCells);
                }
                
                makeBotMove(moveIndex);
            }
            
            // Легкий уровень - случайные ходы
            function getEasyMove(availableCells) {
                return availableCells[Math.floor(Math.random() * availableCells.length)];
            }
            
            // Средний уровень - пытается выиграть или блокировать игрока
            function getMediumMove(availableCells) {
                // Проверяем, может ли бот выиграть
                for (let i = 0; i < availableCells.length; i++) {
                    let testGameState = [...gameState];
                    testGameState[availableCells[i]] = "O";
                    if (checkWinner(testGameState) === "O") {
                        return availableCells[i];
                    }
                }
                
                // Проверяем, нужно ли блокировать игрока
                for (let i = 0; i < availableCells.length; i++) {
                    let testGameState = [...gameState];
                    testGameState[availableCells[i]] = "X";
                    if (checkWinner(testGameState) === "X") {
                        return availableCells[i];
                    }
                }
                
                // Иначе случайный ход
                return availableCells[Math.floor(Math.random() * availableCells.length)];
            }
            
            // Сложный уровень - использует минимакс алгоритм для оптимальной игры
            function getHardMove(availableCells) {
                // Сначала проверяем, может ли бот выиграть
                for (let i = 0; i < availableCells.length; i++) {
                    let testGameState = [...gameState];
                    testGameState[availableCells[i]] = "O";
                    if (checkWinner(testGameState) === "O") {
                        return availableCells[i];
                    }
                }
                
                // Затем проверяем, нужно ли блокировать игрока
                for (let i = 0; i < availableCells.length; i++) {
                    let testGameState = [...gameState];
                    testGameState[availableCells[i]] = "X";
                    if (checkWinner(testGameState) === "X") {
                        return availableCells[i];
                    }
                }
                
                // Стратегические ходы - центр и углы
                const center = 4;
                if (availableCells.includes(center)) {
                    return center;
                }
                
                const corners = [0, 2, 6, 8];
                const availableCorners = corners.filter(corner => availableCells.includes(corner));
                if (availableCorners.length > 0) {
                    return availableCorners[Math.floor(Math.random() * availableCorners.length)];
                }
                
                // Оставшиеся ходы (стороны)
                const sides = [1, 3, 5, 7];
                const availableSides = sides.filter(side => availableCells.includes(side));
                if (availableSides.length > 0) {
                    return availableSides[Math.floor(Math.random() * availableSides.length)];
                }
                
                // Если ничего не найдено, случайный ход
                return availableCells[Math.floor(Math.random() * availableCells.length)];
            }
            
            function makeBotMove(index) {
                const cell = document.querySelector(`.cell[data-index="${index}"]`);
                handleCellPlayed(cell, index);
                handleResultValidation();
            }
            
            function checkWinner(state) {
                for (let i = 0; i < winningConditions.length; i++) {
                    const [a, b, c] = winningConditions[i];
                    if (state[a] && state[a] === state[b] && state[a] === state[c]) {
                        return state[a];
                    }
                }
                return null;
            }
            
            function setGameMode(mode) {
                vsBotMode = mode === 'bot';
                
                // Показываем или скрываем выбор уровня сложности
                difficultyContainer.style.display = vsBotMode ? 'flex' : 'none';
                
                // Обновляем активные кнопки
                modeTwoPlayersBtn.classList.toggle('active', !vsBotMode);
                modeVsBotBtn.classList.toggle('active', vsBotMode);
                
                // Перезапускаем игру
                handleRestartGame();
            }
            
            function setBotDifficulty(difficulty) {
                botDifficulty = difficulty;
                
                // Обновляем активные кнопки
                difficultyEasyBtn.classList.toggle('active', difficulty === 'easy');
                difficultyMediumBtn.classList.toggle('active', difficulty === 'medium');
                difficultyHardBtn.classList.toggle('active', difficulty === 'hard');
                
                // Если игра против бота активна, перезапускаем игру
                if (vsBotMode) {
                    handleRestartGame();
                }
            }
            
            cells.forEach(cell => cell.addEventListener('click', handleCellClick));
            resetButton.addEventListener('click', handleRestartGame);
            modeTwoPlayersBtn.addEventListener('click', () => setGameMode('twoPlayers'));
            modeVsBotBtn.addEventListener('click', () => setGameMode('bot'));
            difficultyEasyBtn.addEventListener('click', () => setBotDifficulty('easy'));
            difficultyMediumBtn.addEventListener('click', () => setBotDifficulty('medium'));
            difficultyHardBtn.addEventListener('click', () => setBotDifficulty('hard'));
        });
    </script>
</body>
</html>
